"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var _reactTransitionContext = require("react-transition-context");

var _inlineStylePrefixer = _interopRequireDefault(require("inline-style-prefixer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const defaultProps = {
  fadeInTransitionDuration: 200,
  fadeInTransitionTimingFunction: 'linear',
  fadeOutTransitionDuration: 200,
  fadeOutTransitionTimingFunction: 'linear',
  sizeTransitionDuration: 200,
  sizeTransitionTimingFunction: 'ease',
  prefixer: new _inlineStylePrefixer.default(),
  style: {},

  shouldTransition(oldChildren, newChildren) {
    if (oldChildren === newChildren) return false;

    if (React.isValidElement(oldChildren) && React.isValidElement(newChildren) && oldChildren.key != null && oldChildren.key === newChildren.key) {
      return false;
    }

    return true;
  }

};

function applyDefaults(props) {
  const result = _objectSpread({}, props);

  for (const key in defaultProps) {
    if (defaultProps.hasOwnProperty(key) && props[key] == null) {
      result[key] = defaultProps[key];
    }
  }

  return result;
}

class Fader extends React.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "lastProps", this.props);

    _defineProperty(this, "getDefaultedProps", () => {
      if (this.lastProps !== this.props || !this.lastDefaultedProps) {
        this.lastProps = this.props;
        this.lastDefaultedProps = applyDefaults(this.props);
      }

      return this.lastDefaultedProps;
    });

    _defineProperty(this, "wrapChildren", (children, transitionState) => {
      const {
        animateWidth,
        prefixer,
        viewStyle,
        innerViewWrapperStyle,
        fadeInTransitionDuration,
        fadeInTransitionTimingFunction,
        fadeOutTransitionDuration,
        fadeOutTransitionTimingFunction
      } = this.getDefaultedProps();

      const style = _objectSpread({
        display: animateWidth ? 'inline-flex' : 'flex',
        transitionProperty: 'opacity'
      }, viewStyle);

      switch (transitionState) {
        case 'out':
        case 'entering':
          style.opacity = transitionState === 'entering' ? 1 : 0;
          style.transitionDuration = fadeInTransitionDuration + 'ms';
          style.transitionTimingFunction = fadeInTransitionTimingFunction;
          break;

        case 'in':
        case 'leaving':
          style.opacity = transitionState === 'in' ? 1 : 0;
          style.transitionDuration = fadeOutTransitionDuration + 'ms';
          style.transitionTimingFunction = fadeOutTransitionTimingFunction;
          break;
      }

      return React.createElement("div", {
        "data-transition-state": transitionState,
        style: prefixer.prefix(style)
      }, React.createElement("div", {
        style: prefixer.prefix(_objectSpread({
          width: '100%'
        }, innerViewWrapperStyle)),
        ref: c => this.wrappedChildrenRef = c
      }, React.createElement(_reactTransitionContext.TransitionContext, {
        state: transitionState
      }, children)));
    });

    _defineProperty(this, "timeouts", {});

    _defineProperty(this, "state", {
      children: this.props.children,
      height: undefined,
      width: undefined,
      wrappedChildren: this.wrapChildren(this.props.children, 'in'),
      transitionState: 'in',
      transitioningSize: false
    });

    _defineProperty(this, "onTransitionEnd", e => {
      const {
        shouldTransition,
        fadeOutTransitionDuration
      } = this.getDefaultedProps();
      const {
        transitionState
      } = this.state;

      if (transitionState === 'leaving') {
        this.setState({
          transitionState: 'out',
          wrappedChildren: this.wrapChildren(this.props.children, 'out')
        });
      } else if (transitionState === 'entering') {
        if (shouldTransition(this.state.children, this.props.children)) {
          this.setState({
            transitionState: 'leaving',
            wrappedChildren: this.wrapChildren(this.state.children, 'leaving')
          });
          this.setTimeout('fadeOut', this.onTransitionEnd, fadeOutTransitionDuration);
        } else {
          this.setState({
            transitionState: 'in',
            height: undefined,
            width: undefined,
            wrappedChildren: this.wrapChildren(this.props.children, 'in')
          });
        }
      }
    });

    _defineProperty(this, "onSizeTransitionEnd", e => {
      this.setState({
        transitioningSize: false
      });
    });
  }

  setTimeout(name, callback, delay) {
    if (this.timeouts[name]) clearTimeout(this.timeouts[name]);
    this.timeouts[name] = setTimeout(callback, delay);
  }

  componentDidUpdate() {
    const {
      transitionState,
      height,
      width,
      transitioningSize
    } = this.state;
    const {
      animateHeight,
      animateWidth,
      shouldTransition: _shouldTransition,
      fadeOutTransitionDuration,
      fadeInTransitionDuration,
      sizeTransitionDuration
    } = this.getDefaultedProps();

    const shouldTransition = _shouldTransition(this.state.children, this.props.children);

    if (transitionState === 'in' && shouldTransition) {
      const newState = {};
      newState.children = this.props.children;
      newState.transitionState = 'leaving';
      newState.wrappedChildren = this.wrapChildren(this.state.children, 'leaving');
      this.setTimeout('fadeOut', this.onTransitionEnd, fadeOutTransitionDuration);

      if (animateHeight && height === undefined && this.wrappedChildrenRef) {
        newState.height = this.wrappedChildrenRef.clientHeight;
      }

      if (animateWidth && width === undefined && this.wrappedChildrenRef) {
        newState.width = this.wrappedChildrenRef.clientWidth;
      }

      this.setState(newState);
    } else if (transitionState === 'leaving' && (animateHeight || animateWidth)) {
      if (!transitioningSize) this.setState({
        transitioningSize: true
      });
    } else if (transitionState === 'out') {
      const newState = {};

      if (shouldTransition) {
        newState.children = this.props.children;
        newState.wrappedChildren = this.wrapChildren(this.props.children, 'out');
      } else {
        newState.transitionState = 'entering';
        newState.children = this.props.children;
        newState.wrappedChildren = this.wrapChildren(this.props.children, 'entering');
        this.setTimeout('fadeIn', this.onTransitionEnd, fadeInTransitionDuration);

        if (animateHeight) {
          if (this.wrappedChildrenRef) {
            newState.height = this.wrappedChildrenRef.clientHeight;
          }

          this.setTimeout('height', this.onSizeTransitionEnd, sizeTransitionDuration);
        }

        if (animateWidth) {
          if (this.wrappedChildrenRef) {
            newState.width = this.wrappedChildrenRef.clientWidth;
          }

          this.setTimeout('width', this.onSizeTransitionEnd, sizeTransitionDuration);
        }
      }

      this.setState(newState);
    } else if (!shouldTransition && this.state.children !== this.props.children) {
      const newState = {};
      newState.children = this.props.children;
      newState.wrappedChildren = this.wrapChildren(this.props.children, transitionState);
      this.setState(newState);
    }
  }

  componentWillUnmount() {
    for (let name in this.timeouts) clearTimeout(this.timeouts[name]);
  }

  render() {
    const {
      height,
      width,
      transitioningSize,
      wrappedChildren
    } = this.state;
    const {
      animateWidth,
      className,
      prefixer,
      innerRef,
      style: _style,
      sizeTransitionDuration,
      sizeTransitionTimingFunction
    } = this.getDefaultedProps();

    const style = _objectSpread({
      height,
      width,
      display: animateWidth ? 'inline-block' : 'block'
    }, _style);

    if (transitioningSize) {
      style.overflow = 'hidden';
      style.transition = `height ${sizeTransitionDuration}ms ${sizeTransitionTimingFunction}, width ${sizeTransitionDuration}ms ${sizeTransitionTimingFunction}`;
    }

    return React.createElement("div", {
      className: className,
      style: prefixer.prefix(style),
      ref: innerRef
    }, wrappedChildren);
  }

}

exports.default = Fader;