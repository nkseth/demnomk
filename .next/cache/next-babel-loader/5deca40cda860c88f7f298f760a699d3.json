{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { createSlice, createAsyncThunk, createAction } from \"@reduxjs/toolkit\";\nimport { client_fetchSearch } from \"../../../../lib/api/client/clientSearch\";\nimport { searchPageFiltersDefaults, SEARCH_TYPE_CATEGORY } from \"../../../../lib/querys\";\nexport const LOADING = \"loading\";\nexport const IDLE = \"idle\";\nexport const SUCCEEDED = \"succeeded\";\nexport const ERROR = \"error\";\nexport const initialState = {\n  status: IDLE,\n  error: null,\n  search: {\n    goods: {\n      count: 0,\n      data: []\n    }\n  },\n  changeUrl: false,\n  filters: searchPageFiltersDefaults,\n  brands: {\n    items: [],\n    selected: []\n  }\n}; //// selectors\n\nexport const selectFilters = state => state.search.filters;\nexport const selectGoods = state => state.search.search.goods;\nexport const selectSearch = state => state.search.search;\nexport const selectSpecs = state => state.search.search.specs;\nexport const selectBrands = state => state.search.brands.items;\nexport const selectSelectedBrands = state => state.search.brands.selected; /// server action creator\n\nexport const serverSearchUpdate = createAction(\"search/serverUpdate\"); //// thunk actions\n\nexport const fetchSearch = createAsyncThunk(\"search/fetchSearch\", async (data, {\n  dispatch\n}) => {\n  dispatch(changeUrl());\n  const result = await client_fetchSearch(data);\n  return result;\n}); /// search slice\n\nconst searchSlice = createSlice({\n  name: \"search\",\n  initialState,\n  reducers: {\n    changeUrl(state) {\n      state.changeUrl = !state.changeUrl;\n    },\n\n    orderByTypeAdded(state, action) {\n      state.filters.orderByType = action.payload;\n    },\n\n    pageSizeAdded(state, action) {\n      state.filters.pageSize = action.payload;\n    },\n\n    priceAdded(state, action) {\n      state.filters.fromPrice = action.payload.fromPrice;\n      state.filters.toPrice = action.payload.toPrice;\n    },\n\n    goodsCreatedDayAdded(state, action) {\n      state.filters.goodsCreatedDay = action.payload;\n    },\n\n    goodsOptionsAdded(state, action) {\n      state.filters.optionIds = action.payload;\n    },\n\n    brandsChanged(state, action) {\n      const id = parseInt(action.payload.brand.id);\n\n      if (action.payload.checked) {\n        state.filters.brandId.push(id);\n        state.brands.selected.push(action.payload.brand);\n      } else {\n        // if is remove\n        const newSelected = state.brands.selected.filter(brand => {\n          return brand.id != id;\n        });\n        const index = state.filters.brandId.indexOf(id);\n\n        if (index > -1) {\n          state.filters.brandId.splice(index, 1);\n        }\n\n        state.brands.selected = newSelected;\n      }\n    },\n\n    pageChanged(state, action) {\n      state.filters.pageNumber = action.payload;\n    },\n\n    mobileFilterUpdate(state, action) {\n      const specsId = action.payload.specsId;\n      const arrival = action.payload.arrival;\n      const priceFrom = action.payload.price.min || state.filters.fromPrice;\n      const priceTo = action.payload.price.max || state.filters.toPrice;\n      state.filters.brandId = action.payload.brands.ids;\n      state.brands.selected = action.payload.brands.selected;\n      state.filters.optionIds = specsId;\n      state.filters.goodsCreatedDay = parseInt(arrival);\n      state.filters.fromPrice = parseInt(priceFrom);\n      state.filters.toPrice = parseInt(priceTo);\n      state.filters.justExist = action.payload.justExist;\n    },\n\n    categoryClick(state, action) {\n      state.filters.id = action.payload;\n      state.filters.type = SEARCH_TYPE_CATEGORY;\n    },\n\n    changeJustExist(state, action) {\n      state.filters.justExist = action.payload;\n    }\n\n  },\n  extraReducers: {\n    [fetchSearch.pending]: (state, action) => {\n      state.status = LOADING;\n    },\n    [fetchSearch.fulfilled]: (state, action) => {\n      var _result$specs, _result$brands;\n\n      state.status = SUCCEEDED;\n      const result = action.payload.result; //// generate optimize specs\n\n      const newSpecs = {};\n      (_result$specs = result.specs) === null || _result$specs === void 0 ? void 0 : _result$specs.forEach(spec => {\n        var _spec$options;\n\n        const newOptions = {};\n        (_spec$options = spec.options) === null || _spec$options === void 0 ? void 0 : _spec$options.forEach(option => {\n          newOptions[option.optionId] = option;\n        });\n        newSpecs[spec.specId] = _objectSpread(_objectSpread({}, spec), {}, {\n          options: newOptions\n        });\n      }); //// generate optimized brands\n\n      const newBrands = {};\n      (_result$brands = result.brands) === null || _result$brands === void 0 ? void 0 : _result$brands.forEach(brand => {\n        newBrands[brand.brandId] = brand;\n      });\n      result.specs = newSpecs;\n      result.brands = newBrands;\n      state.search = result;\n    },\n    [fetchSearch.rejected]: (state, action) => {\n      state.status = ERROR;\n    },\n    [serverSearchUpdate]: (state, action) => {\n      var _result$specs2, _result$brands2, _action$payload$brand;\n\n      const result = action.payload.search;\n      const newSpecs = {};\n      (_result$specs2 = result.specs) === null || _result$specs2 === void 0 ? void 0 : _result$specs2.forEach(spec => {\n        var _spec$options2;\n\n        const newOptions = {};\n        (_spec$options2 = spec.options) === null || _spec$options2 === void 0 ? void 0 : _spec$options2.forEach(option => {\n          newOptions[option.optionId] = option;\n        });\n        newSpecs[spec.specId] = _objectSpread(_objectSpread({}, spec), {}, {\n          options: newOptions\n        });\n      }); //// generate optimized brands\n\n      const newBrands = {};\n      (_result$brands2 = result.brands) === null || _result$brands2 === void 0 ? void 0 : _result$brands2.forEach(brand => {\n        newBrands[brand.brandId] = brand;\n      }); // generate selected brands\n\n      let selectedBrands = [];\n      (_action$payload$brand = action.payload.brands) === null || _action$payload$brand === void 0 ? void 0 : _action$payload$brand.forEach(brand => {\n        selectedBrands.push({\n          value: brand.brandTitle,\n          id: brand.brandId\n        });\n      });\n      result.brands = newBrands;\n      result.specs = newSpecs;\n      state.status = SUCCEEDED;\n      state.search = result;\n      state.filters = action.payload.filters;\n      state.brands.selected = selectedBrands;\n    }\n  }\n});\nexport const {\n  orderByTypeAdded,\n  pageSizeAdded,\n  priceAdded,\n  goodsCreatedDayAdded,\n  changeUrl,\n  goodsOptionsAdded,\n  brandsChanged,\n  pageChanged,\n  mobileFilterUpdate,\n  categoryClick,\n  changeJustExist\n} = searchSlice.actions;\nexport const orderByTypeAddedAction = orderType => {\n  return (dispatch, getState) => {\n    dispatch(orderByTypeAdded(orderType));\n    dispatch(fetchSearch(selectFilters(getState())));\n  };\n};\nexport const pageSizeAddedAction = pageSize => {\n  return (dispatch, getState) => {\n    dispatch(pageSizeAdded(pageSize));\n    dispatch(fetchSearch(selectFilters(getState())));\n  };\n};\nexport const priceAddedAction = (from, to) => {\n  return (dispatch, getState) => {\n    dispatch(priceAdded({\n      fromPrice: from,\n      toPrice: to\n    }));\n    dispatch(fetchSearch(selectFilters(getState())));\n  };\n};\nexport const goodsCreatedDayAddedAction = goodsCreatedDay => {\n  return (dispatch, getState) => {\n    if (!goodsCreatedDay) goodsCreatedDay = initialState.filters.goodsCreatedDay;\n    dispatch(goodsCreatedDayAdded(parseInt(goodsCreatedDay)));\n    dispatch(fetchSearch(selectFilters(getState())));\n  };\n};\nexport const goodsOptionsAddedAction = options => {\n  return (dispatch, getState) => {\n    dispatch(goodsOptionsAdded(options));\n    dispatch(fetchSearch(selectFilters(getState())));\n  };\n};\nexport const brandsChangedAction = (brand, checked) => {\n  return (dispatch, getState) => {\n    dispatch(brandsChanged({\n      brand,\n      checked\n    }));\n    dispatch(fetchSearch(selectFilters(getState())));\n  };\n};\nexport const brandsRemovedAction = id => {\n  return (dispatch, getState) => {\n    const curr_state = getState();\n    const newBrands = selectFilters(curr_state).brandId.filter(brandId => {\n      return brandId !== id;\n    });\n    dispatch(brandAdded(newBrands));\n    dispatch(fetchSearch(selectFilters(getState())));\n  };\n};\nexport const pageChangedAction = pageNumber => {\n  return (dispatch, getState) => {\n    dispatch(pageChanged(pageNumber));\n    dispatch(fetchSearch(selectFilters(getState())));\n  };\n};\nexport const mobileFilterUpdateAction = newFilters => {\n  return (dispatch, getState) => {\n    dispatch(mobileFilterUpdate(newFilters));\n    dispatch(fetchSearch(selectFilters(getState())));\n  };\n};\nexport const categoryClickAction = catId => {\n  return (dispatch, getState) => {\n    dispatch(categoryClick(catId)); // dispatch(fetchSearch(selectFilters(getState())));\n  };\n};\nexport const justExistClickAction = exist => {\n  return (dispatch, getState) => {\n    dispatch(changeJustExist(exist));\n    dispatch(fetchSearch(selectFilters(getState())));\n  };\n};\nexport default searchSlice.reducer;","map":null,"metadata":{},"sourceType":"module"}