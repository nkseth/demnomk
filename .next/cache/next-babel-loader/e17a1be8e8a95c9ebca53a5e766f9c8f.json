{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from \"react\";\nimport { Translate } from \"react-localize-redux\";\nimport { ReactComponent as BackIcon } from \"./../../../../../../../assets/icons/back.svg\";\nimport GoogleMapReact from \"google-map-react\";\nimport PlaceHolderIcon from \"./../../../../../../../assets/icons/placeholder.svg\";\nimport LoadingGif from \"./../../../../../../../assets/icons/5.gif\";\nimport Geocode from \"react-geocode\";\nimport { ReactComponent as TargetIcon } from \"./../../../../../../../assets/icons/target.svg\";\nimport { toast } from \"react-toastify\";\nimport { getErrorMsg } from \"../../../../../../../lib/helpers\";\nimport { getToastConfig } from \"../../../../../../../lib/toast\";\nimport { connect } from \"react-redux\";\nimport { selectLang } from \"../../../../../../../appConfigSlice\"; // const AnyReactComponent = ({ text }) => <div>{text}</div>;\n\nclass SelectAddress extends React.Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"addressWindowContent\", () => {\n      return `<div class=\"map__add-cnt\">\n    <h3 class=\"map__header\"></h3>\n    <div class=\"map__content\">\n    <img class=\"map__loading-icon\" src=\"${LoadingGif}\" />\n    </div>\n    </div>`;\n    });\n\n    _defineProperty(this, \"handleBackClick\", () => {\n      this.props.handleSituation({\n        type: \"hideMap\"\n      });\n    });\n\n    _defineProperty(this, \"setAddressInWindowContent\", response => {\n      const name = response.results[1].formatted_address;\n      const addr = response.results[0].formatted_address;\n      this.infowindow.setContent(`<div class=\"map__add-cnt\">\n    <h3 class=\"map__header\">${name}</h3>\n    <div class=\"map__content\">\n    ${addr}\n    </div>\n    </div>`);\n    });\n\n    _defineProperty(this, \"getAddress\", (lat, lng, cb) => {\n      Geocode.setApiKey(this.API_KEY);\n      Geocode.fromLatLng(lat, lng, null, this.props.lang).then(response => {\n        const address = response.results[0].formatted_address;\n\n        if (this.props.selectedCountry !== undefined && this.props.selectedCountry !== null) {\n          const currentCountry = response.results[1].address_components.find(x => x.types[0] == \"country\").long_name;\n\n          if (currentCountry !== this.props.selectedCountry) {\n            this.markers.forEach(marker => {\n              marker.setMap(null);\n            });\n            toast.error(getErrorMsg(this.props.lang, \"error-city-create-shop\"), getToastConfig());\n          }\n        } // console.log(address);\n\n\n        cb(response); // this.setAddressInWindowContent(response.results[1].formatted_address,address);\n      }, error => {\n        console.error(error);\n      });\n    });\n\n    _defineProperty(this, \"setCurLocation\", e => {\n      e.preventDefault();\n\n      if (navigator.geolocation) {\n        navigator.geolocation.getCurrentPosition(position => {\n          const pos = {\n            lat: position.coords.latitude,\n            lng: position.coords.longitude\n          };\n          this.map.setCenter(pos);\n          this.markers.forEach(marker => {\n            marker.setMap(null);\n          });\n          this.markers = [];\n          this.markers.push(new this.maps.Marker({\n            position: pos,\n            map: this.map,\n            icon: PlaceHolderIcon\n          }));\n          this.selectedMarker = this.markers[0];\n          this.infowindow.setContent(this.addressWindowContent());\n          this.infowindow.open(this.map, this.selectedMarker);\n          this.getAddress(this.selectedMarker.position.lat(), this.selectedMarker.position.lng(), this.setAddressInWindowContent);\n        }, function () {// handleLocationError(true, infoWindow, map.getCenter());\n        });\n      } else {// Browser doesn't support Geolocation\n        // handleLocationError(false, infoWindow, map.getCenter());\n      }\n    });\n\n    _defineProperty(this, \"handleSearchBox\", (map, maps) => {\n      const searchBox = new maps.places.SearchBox(this.searchInput.current);\n      map.controls[maps.ControlPosition.TOP_CENTER].push(this.searchInput.current);\n      map.controls[maps.ControlPosition.TOP_LEFT].push(this.targetBtn.current);\n      map.addListener(\"bounds_changed\", () => {\n        searchBox.setBounds(map.getBounds());\n      });\n      this.markers = []; // Listen for the event fired when the user selects a prediction and retrieve\n      // more details for that place.\n\n      searchBox.addListener(\"places_changed\", () => {\n        const places = searchBox.getPlaces();\n\n        if (places.length == 0) {\n          return;\n        } // console.log(places);\n        // Clear out the old markers.\n\n\n        this.markers.forEach(marker => {\n          marker.setMap(null);\n        });\n        this.markers = []; // For each place, get the icon, name and location.\n\n        const bounds = new maps.LatLngBounds();\n        places.forEach(place => {\n          if (!place.geometry) {\n            return;\n          }\n\n          const icon = {\n            url: PlaceHolderIcon,\n            size: new maps.Size(71, 71),\n            origin: new maps.Point(0, 0),\n            anchor: new maps.Point(17, 34),\n            scaledSize: new maps.Size(25, 25)\n          }; // Create a marker for each place.\n\n          this.markers.push(new maps.Marker({\n            map,\n            icon,\n            title: place.name,\n            position: place.geometry.location\n          }));\n\n          if (place.geometry.viewport) {\n            // Only geocodes have viewport.\n            bounds.union(place.geometry.viewport);\n          } else {\n            bounds.extend(place.geometry.location);\n          }\n        });\n        map.fitBounds(bounds);\n      });\n    });\n\n    _defineProperty(this, \"handleApiLoaded\", (map, maps) => {\n      this.map = map;\n      this.maps = maps;\n      this.handleSearchBox(map, maps);\n      this.infowindow = new maps.InfoWindow({\n        content: this.addressWindowContent()\n      });\n\n      if (this.props.lat && this.props.lng && !this.props.dontSetLocation) {\n        const pos = {\n          lat: this.props.lat,\n          lng: this.props.lng\n        };\n        this.markers.push(new maps.Marker({\n          position: pos,\n          map,\n          icon: PlaceHolderIcon\n        }));\n        this.selectedMarker = this.markers[0];\n        this.infowindow.setContent(this.addressWindowContent());\n        this.infowindow.open(map, this.selectedMarker);\n        this.getAddress(this.selectedMarker.position.lat(), this.selectedMarker.position.lng(), this.setAddressInWindowContent);\n      }\n\n      map.addListener(\"click\", e => {\n        this.markers.forEach(marker => {\n          marker.setMap(null);\n        });\n        this.markers = [];\n        this.markers.push(new maps.Marker({\n          position: e.latLng,\n          map,\n          icon: PlaceHolderIcon\n        }));\n        this.selectedMarker = this.markers[0];\n        this.infowindow.setContent(this.addressWindowContent());\n        this.infowindow.open(map, this.selectedMarker);\n        this.getAddress(this.selectedMarker.position.lat(), this.selectedMarker.position.lng(), this.setAddressInWindowContent);\n      });\n    });\n\n    _defineProperty(this, \"handleSubmit\", () => {\n      if (!this.selectedMarker) {\n        alert(\"you should select your location first\");\n        return;\n      }\n\n      this.setState({\n        showSubmitLoading: true\n      }, () => {\n        this.getAddress(this.selectedMarker.position.lat(), this.selectedMarker.position.lng(), response => {\n          let iso = \"\";\n\n          for (let index = 0; index < response.results[0].address_components.length; index++) {\n            if (response.results[0].address_components[index].types.includes(\"country\")) {\n              iso = response.results[0].address_components[index].short_name;\n            }\n          }\n\n          this.props.setData({\n            address: response.results[0].formatted_address,\n            Location: response.results[0].geometry.location,\n            iso: iso\n          });\n          this.handleBackClick();\n        });\n      });\n    });\n\n    this.searchInput = /*#__PURE__*/React.createRef();\n    this.targetBtn = /*#__PURE__*/React.createRef();\n    this.markers = [];\n    this.selectedMarker = null;\n    this.API_KEY = process.env.NEXT_PUBLIC_GOOGLE_MAP_API_KEY;\n    this.infowindow = null;\n    this.map = null;\n    this.maps = null;\n    this.state = {\n      showSubmitLoading: false\n    };\n    this.center = {\n      lat: this.props.lat ? this.props.lat : parseInt(process.env.NEXT_PUBLIC_GOOGLE_MAP_Default_lat),\n      lng: this.props.lng ? this.props.lng : parseInt(process.env.NEXT_PUBLIC_GOOGLE_MAP_Default_lng)\n    };\n    this.zoom = this.props.zoom ? this.props.zoom : 11;\n    this.setCurLocation.bind(this);\n  }\n\n  componentDidMount() {}\n\n  render() {\n    return __jsx(Translate, null, ({\n      translate: t\n    }) => {\n      return __jsx(React.Fragment, null, __jsx(\"section\", {\n        className: \"mapAddress\"\n      }, __jsx(\"header\", {\n        className: \"mapAddress__header\"\n      }, __jsx(\"a\", {\n        on: true,\n        onClick: this.handleBackClick\n      }, __jsx(BackIcon, {\n        className: \"mapAddress__back-icon\"\n      }), __jsx(\"span\", {\n        className: \"mapAddress__header-text\"\n      }, __jsx(Translate, {\n        id: \"addresses.addresses\"\n      })))), __jsx(\"div\", {\n        id: \"map\",\n        className: \"mapAddress__map-cnt\"\n      }, __jsx(\"input\", {\n        placeholder: t(\"addresses.search-loc-placeholder\"),\n        type: \"text\",\n        className: \"gray__input mapAddress__searchInput\",\n        ref: this.searchInput\n      }), __jsx(GoogleMapReact, {\n        yesIWantToUseGoogleMapApiInternals: true,\n        onGoogleApiLoaded: ({\n          map,\n          maps\n        }) => this.handleApiLoaded(map, maps),\n        bootstrapURLKeys: {\n          key: this.API_KEY,\n          libraries: \"places\"\n        },\n        defaultCenter: this.center,\n        defaultZoom: this.zoom\n      }), __jsx(\"button\", {\n        onClick: $event => this.setCurLocation($event),\n        className: \"mapAddress__curr-btn\",\n        ref: this.targetBtn,\n        type: \"button\"\n      }, __jsx(TargetIcon, {\n        className: \"mapAddress__target-icon\"\n      }))), __jsx(\"div\", {\n        className: \"mapAddress__btn-cnt\"\n      }, __jsx(\"button\", {\n        onClick: this.handleSubmit,\n        className: \"primary-btn add-address-step1__btn\",\n        type: \"button\"\n      }, this.state.showSubmitLoading ? __jsx(\"img\", {\n        className: \"map__loading-icon\",\n        src: LoadingGif\n      }) : t(\"addresses.confirm-loc\")))));\n    });\n  }\n\n}\n\nconst mapStateToProps = state => {\n  return {\n    lang: selectLang(state)\n  };\n};\n\nexport default connect(mapStateToProps)(SelectAddress);","map":null,"metadata":{},"sourceType":"module"}