{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from \"react\";\nimport { Translate } from \"react-localize-redux\";\nimport { ReactComponent as BackIcon } from \"./../../../../../../assets/icons/back.svg\";\nimport GoogleMapReact from \"google-map-react\";\nimport PlaceHolderIcon from \"./../../../../../../assets/icons/placeholder.svg\";\nimport LoadingGif from \"./../../../../../../assets/icons/5.gif\";\nimport Geocode from \"react-geocode\";\nimport { ReactComponent as TargetIcon } from \"./../../../../../../assets/icons/target.svg\";\nimport { client_areaCheck } from \"../../../../../../lib/api/client/clientMap\";\nimport { Loading } from \"../../../../../common\"; // const AnyReactComponent = ({ text }) => <div>{text}</div>;\n\nvar _default = /*#__PURE__*/function (_React$Component) {\n  _inherits(_default, _React$Component);\n\n  var _super = _createSuper(_default);\n\n  function _default(props) {\n    var _this;\n\n    _classCallCheck(this, _default);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"addressWindowContent\", function () {\n      return \"<div class=\\\"map__add-cnt\\\">\\n    <h3 class=\\\"map__header\\\"></h3>\\n    <div class=\\\"map__content\\\">\\n    <img class=\\\"map__loading-icon\\\" src=\\\"\".concat(LoadingGif, \"\\\" />\\n    </div>\\n    </div>\");\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleBackClick\", function () {\n      _this.props.back();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"setAddressInWindowContent\", function (response) {\n      var name = response.cityName;\n      var addr = response.address;\n\n      _this.infowindow.setContent(\"<div class=\\\"map__add-cnt\\\">\\n    <h3 class=\\\"map__header\\\">\".concat(name, \"</h3>\\n    <div class=\\\"map__content\\\">\\n    \").concat(addr, \"\\n    </div>\\n    </div>\"));\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getAddress\", /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(lat, lng, cb) {\n        var results;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return client_areaCheck(lat, lng);\n\n              case 3:\n                results = _context.sent;\n\n                if (results.status === 200) {\n                  // console.log(results.results)\n                  cb(results.result);\n                }\n\n                _context.next = 12;\n                break;\n\n              case 7:\n                _context.prev = 7;\n                _context.t0 = _context[\"catch\"](0);\n\n                _this.props.areaError(_context.t0);\n\n                _this.setState({\n                  showSubmitLoading: false\n                });\n\n                _this.infowindow.close();\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[0, 7]]);\n      }));\n\n      return function (_x, _x2, _x3) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n\n    _defineProperty(_assertThisInitialized(_this), \"setCurLocation\", function (e) {\n      e.preventDefault();\n\n      if (navigator.geolocation) {\n        navigator.geolocation.getCurrentPosition(function (position) {\n          var pos = {\n            lat: position.coords.latitude,\n            lng: position.coords.longitude\n          };\n\n          _this.map.setCenter(pos);\n\n          _this.markers.forEach(function (marker) {\n            marker.setMap(null);\n          });\n\n          _this.markers = [];\n\n          _this.markers.push(new _this.maps.Marker({\n            position: pos,\n            map: _this.map,\n            icon: PlaceHolderIcon\n          }));\n\n          _this.selectedMarker = _this.markers[0];\n\n          _this.infowindow.setContent(_this.addressWindowContent());\n\n          _this.infowindow.open(_this.map, _this.selectedMarker);\n\n          _this.getAddress(_this.selectedMarker.position.lat(), _this.selectedMarker.position.lng(), _this.setAddressInWindowContent);\n        }, function () {// handleLocationError(true, infoWindow, map.getCenter());\n        });\n      } else {// Browser doesn't support Geolocation\n        // handleLocationError(false, infoWindow, map.getCenter());\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleSearchBox\", function (map, maps) {\n      var searchBox = new maps.places.SearchBox(_this.searchInput.current);\n      map.controls[maps.ControlPosition.TOP_CENTER].push(_this.searchInput.current);\n      map.controls[maps.ControlPosition.TOP_LEFT].push(_this.targetBtn.current);\n      map.addListener(\"bounds_changed\", function () {\n        searchBox.setBounds(map.getBounds());\n      });\n      _this.markers = []; // Listen for the event fired when the user selects a prediction and retrieve\n      // more details for that place.\n\n      searchBox.addListener(\"places_changed\", function () {\n        var places = searchBox.getPlaces();\n\n        if (places.length == 0) {\n          return;\n        } // console.log(places);\n        // Clear out the old markers.\n\n\n        _this.markers.forEach(function (marker) {\n          marker.setMap(null);\n        });\n\n        _this.markers = []; // For each place, get the icon, name and location.\n\n        var bounds = new maps.LatLngBounds();\n        places.forEach(function (place) {\n          if (!place.geometry) {\n            console.log(\"Returned place contains no geometry\");\n            return;\n          }\n\n          var icon = {\n            url: PlaceHolderIcon,\n            size: new maps.Size(71, 71),\n            origin: new maps.Point(0, 0),\n            anchor: new maps.Point(17, 34),\n            scaledSize: new maps.Size(25, 25)\n          }; // Create a marker for each place.\n\n          _this.markers.push(new maps.Marker({\n            map: map,\n            icon: icon,\n            title: place.name,\n            position: place.geometry.location\n          }));\n\n          if (place.geometry.viewport) {\n            // Only geocodes have viewport.\n            bounds.union(place.geometry.viewport);\n          } else {\n            bounds.extend(place.geometry.location);\n          }\n        });\n        map.fitBounds(bounds);\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleApiLoaded\", function (map, maps) {\n      _this.map = map;\n      _this.maps = maps;\n\n      _this.handleSearchBox(map, maps);\n\n      _this.infowindow = new maps.InfoWindow({\n        content: _this.addressWindowContent()\n      });\n\n      if (_this.props.lat && _this.props.lng) {\n        _this.markers = [];\n\n        _this.markers.push(new maps.Marker({\n          position: {\n            lat: _this.props.lat,\n            lng: _this.props.lng\n          },\n          map: map,\n          icon: PlaceHolderIcon\n        }));\n\n        _this.selectedMarker = _this.markers[0];\n      }\n\n      map.addListener(\"click\", function (e) {\n        _this.markers.forEach(function (marker) {\n          marker.setMap(null);\n        });\n\n        _this.markers = [];\n\n        _this.markers.push(new maps.Marker({\n          position: e.latLng,\n          map: map,\n          icon: PlaceHolderIcon\n        }));\n\n        _this.selectedMarker = _this.markers[0];\n\n        _this.infowindow.setContent(_this.addressWindowContent());\n\n        _this.infowindow.open(map, _this.selectedMarker);\n\n        _this.getAddress(_this.selectedMarker.position.lat(), _this.selectedMarker.position.lng(), _this.setAddressInWindowContent);\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleSubmit\", function () {\n      if (!_this.selectedMarker) {\n        alert(\"you should select your location first\");\n        return;\n      }\n\n      _this.setState({\n        showSubmitLoading: true\n      }, function () {\n        _this.getAddress(_this.selectedMarker.position.lat(), _this.selectedMarker.position.lng(), function (response) {\n          // this.props.setData({\n          //   address: response.results[0].formatted_address,\n          // });\n          // this.handleBackClick();\n          _this.props.handleSubmit({\n            address: response.address,\n            lat: response.locationX,\n            lng: response.locationY,\n            phoneCode: response.phoneCode,\n            iso: response.iso\n          });\n        });\n      });\n    });\n\n    _this.searchInput = /*#__PURE__*/React.createRef();\n    _this.targetBtn = /*#__PURE__*/React.createRef();\n    _this.markers = [];\n    _this.selectedMarker = null;\n    _this.API_KEY = process.env.NEXT_PUBLIC_GOOGLE_MAP_API_KEY;\n    _this.infowindow = null;\n    _this.map = null;\n    _this.maps = null;\n\n    _this.setCurLocation.bind(_assertThisInitialized(_this));\n\n    _this.state = {\n      showSubmitLoading: false\n    };\n    _this.center = {\n      lat: _this.props.lat ? _this.props.lat : parseInt(process.env.NEXT_PUBLIC_GOOGLE_MAP_Default_lat),\n      lng: _this.props.lng ? _this.props.lng : parseInt(process.env.NEXT_PUBLIC_GOOGLE_MAP_Default_lng)\n    };\n    _this.zoom = _this.props.zoom ? _this.props.zoom : 9;\n    return _this;\n  }\n\n  _createClass(_default, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      return __jsx(Translate, null, function (_ref2) {\n        var t = _ref2.translate;\n        return __jsx(React.Fragment, null, __jsx(\"section\", {\n          className: \"mapAddress\"\n        }, __jsx(\"header\", {\n          className: \"mapAddress__header mapAddress__header--order\"\n        }, __jsx(\"a\", {\n          onClick: _this2.handleBackClick\n        }, __jsx(BackIcon, {\n          className: \"mapAddress__back-icon\"\n        }), __jsx(\"span\", {\n          className: \"mapAddress__header-text\"\n        }, __jsx(Translate, {\n          id: \"addresses.addresses\"\n        })))), __jsx(\"div\", {\n          id: \"map\",\n          className: \"mapAddress__map-cnt\"\n        }, __jsx(\"input\", {\n          placeholder: t(\"addresses.search-loc-placeholder\"),\n          type: \"text\",\n          className: \"gray__input mapAddress__searchInput\",\n          ref: _this2.searchInput\n        }), __jsx(GoogleMapReact, {\n          yesIWantToUseGoogleMapApiInternals: true,\n          onGoogleApiLoaded: function onGoogleApiLoaded(_ref3) {\n            var map = _ref3.map,\n                maps = _ref3.maps;\n            return _this2.handleApiLoaded(map, maps);\n          },\n          bootstrapURLKeys: {\n            key: _this2.API_KEY,\n            libraries: \"places\"\n          },\n          defaultCenter: _this2.center,\n          defaultZoom: _this2.zoom\n        }), __jsx(\"button\", {\n          onClick: function onClick($event) {\n            return _this2.setCurLocation($event);\n          },\n          className: \"mapAddress__curr-btn\",\n          ref: _this2.targetBtn,\n          type: \"button\"\n        }, __jsx(TargetIcon, {\n          className: \"mapAddress__target-icon\"\n        }))), __jsx(\"div\", {\n          className: \"mapAddress__btn-cnt\"\n        }, __jsx(\"button\", {\n          onClick: _this2.handleSubmit,\n          className: \"primary-btn add-address-step1__btn\",\n          type: \"button\"\n        }, _this2.state.showSubmitLoading ? __jsx(Loading, {\n          type: \"white\",\n          width: \"20px\",\n          height: \"20px\"\n        }) : t(\"addresses.confirm-loc\")))));\n      });\n    }\n  }]);\n\n  return _default;\n}(React.Component);\n\nexport { _default as default };","map":null,"metadata":{},"sourceType":"module"}